name: Sync ips from repo1 and compile SRS

on:
  schedule:
    # 每6小时检查一次（北京时间：02:00、08:00、14:00、20:00）
    - cron: "0 */6 * * *"
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - ".github/workflows/sync-and-compile.yml"

jobs:
  sync_and_compile:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout this repo (repo2)
        uses: actions/checkout@v4

      - name: Prepare directories
        run: |
          mkdir -p ips
          mkdir -p upstream
          mkdir -p rules-src
          mkdir -p srs

      - name: Fetch repo1 ips branch
        run: |
          # 克隆仓库1（DustinWin/geoip）的 ips 分支（只拉取最新一次提交）
          git clone --depth 1 -b ips https://github.com/DustinWin/geoip.git upstream

      - name: Copy updated files from repo1/ips to repo2/ips
        id: copy_step
        run: |
          # 把 upstream/（仓库1）里的所有文件直接覆盖到当前仓库的 ips 文件夹
          # 只复制文件，不复制.git目录
          rsync -av --delete --exclude=".git" upstream/ ips/

          # 标记是否有变更（相对于当前仓库的最新提交）
          # 如果有文件变化，CHANGED=true；否则为false
          git add ips
          if git diff --cached --quiet -- ips; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "本次无变更，跳过编译与提交。"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "检测到变更，将进行编译与提交。"
          fi

      - name: Commit synced files
        if: steps.copy_step.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git commit -m "同步更新：从 DustinWin/geoip@ips 复制到 ips 目录"
          git push

      - name: Download sing-box
        if: steps.copy_step.outputs.changed == 'true'
        run: |
          curl -L -o sing-box.tar.gz https://github.com/SagerNet/sing-box/releases/latest/download/sing-box-linux-amd64.tar.gz
          mkdir -p sb
          tar -xzf sing-box.tar.gz -C sb
          chmod +x sb/sing-box
          ./sb/sing-box version || true

      - name: Generate rule-set source JSON from list/txt
        if: steps.copy_step.outputs.changed == 'true'
        run: |
          rm -rf rules-src srs
          mkdir -p rules-src srs

          # 说明：
          # 1. 逐个处理 ips 文件夹里的所有 .txt/.list
          # 2. 自动把合法的 CIDR/IP 行做成 ipcidr 类型
          # 3. 自动把域名（非IP的纯域名）行做成 domain 类型（plain）
          # 4. 每个源文件会生成 1~2 个 .json（有内容才生成），最后编译成同名 .srs（合并在一个文件里）

          normalize_file() {
            # 去掉空行、前后空格、注释行（以#或//开头）
            # 并统一只保留第一列内容（避免行里多余空格）
            awk '
              {
                gsub(/\r/,"");              # 去掉回车
                gsub(/^[ \t]+|[ \t]+$/, "");# 去掉首尾空格
              }
              /^[ \t]*$/ { next }           # 跳过空行
              /^[#]/ { next }               # 跳过#注释
              /^\/\// { next }              # 跳过//注释
              { print $1 }
            ' "$1"
          }

          is_cidr_or_ip() {
            # 判断一行是否为IPv4/IPv6或CIDR
            echo "$1" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}(/[0-9]{1,2})?$|^([0-9a-fA-F:]+)(/[0-9]{1,3})?$'
          }

          is_domain_plain() {
            # 判断是否为纯域名（不含协议/路径/通配符），简单规则：只含字母、数字、点、短横线
            # 并且至少包含一个点（像 example.com）
            echo "$1" | grep -Eq '^[A-Za-z0-9.-]+\.[A-Za-z0-9.-]+$'
          }

          # 遍历 ips 目录下的 .txt/.list 文件
          find ips -type f \( -name "*.txt" -o -name "*.list" \) | while read -r SRC; do
            basename=$(basename "$SRC")
            name="${basename%.*}"   # 去掉扩展名，比如 cn.txt -> cn

            tmp_ip="tmp_${name}_ip.txt"
            tmp_domain="tmp_${name}_domain.txt"
            : > "$tmp_ip"
            : > "$tmp_domain"

            # 规范化并分类
            normalize_file "$SRC" | while read -r line; do
              if is_cidr_or_ip "$line"; then
                echo "$line" >> "$tmp_ip"
              elif is_domain_plain "$line"; then
                echo "$line" >> "$tmp_domain"
              fi
            done

            # 生成 JSON（有内容才生成）
            cnt_ip=$(wc -l < "$tmp_ip")
            cnt_domain=$(wc -l < "$tmp_domain")

            # 如果至少有一种内容，创建一个合并的 JSON 源（同名）
            if [ "$cnt_ip" -gt 0 ] || [ "$cnt_domain" -gt 0 ]; then
              json="rules-src/${name}.json"
              echo '{' > "$json"

              first_block=true

              if [ "$cnt_ip" -gt 0 ]; then
                # 添加 ipcidr 块
                if [ "$first_block" = false ]; then echo ',' >> "$json"; fi
                echo '"type":"ipcidr","content":[' >> "$json"
                awk 'NF{printf "\"%s\",", $0}' "$tmp_ip" | sed 's/,$//' >> "$json"
                echo ']' >> "$json"
                first_block=false
              fi

              if [ "$cnt_domain" -gt 0 ]; then
                # 如果之前已经写了 ipcidr，需要把当前结构改成合并结构
                if [ "$first_block" = false ]; then
                  # 将已有JSON转换为“多段合并”的结构：sources:[ {...}, {...} ]
                  # 简化做法：分别生成两个文件，再合并编译（更直观，避免复杂拼接）
                  rm -f "$json"
                  # 生成独立源文件
                  echo '{"type":"ipcidr","content":[' > "rules-src/${name}.ip.json"
                  awk 'NF{printf "\"%s\",", $0}' "$tmp_ip" | sed 's/,$//' >> "rules-src/${name}.ip.json"
                  echo ']}' >> "rules-src/${name}.ip.json"

                  echo '{"type":"domain","mode":"plain","content":[' > "rules-src/${name}.domain.json"
                  awk 'NF{printf "\"%s\",", $0}' "$tmp_domain" | sed 's/,$//' >> "rules-src/${name}.domain.json"
                  echo ']}' >> "rules-src/${name}.domain.json"

                  # 标记合并编译
                  echo "merge_two_sources=${name}" >> $GITHUB_ENV
                else
                  # 只有域名，没有IP，直接生成一个 domain 源
                  echo '{"type":"domain","mode":"plain","content":[' > "$json"
                  awk 'NF{printf "\"%s\",", $0}' "$tmp_domain" | sed 's/,$//' >> "$json"
                  echo ']}' >> "$json"
                fi
              fi
            fi

            rm -f "$tmp_ip" "$tmp_domain"
          done

      - name: Compile SRS files
        if: steps.copy_step.outputs.changed == 'true'
        run: |
          # 编译规则集：
          # 1) 对 rules-src/*.json，直接编译成 srs/同名.srs
          # 2) 对同时存在 ip.json + domain.json 的同名源，合并编译成一个 srs（文件名为原始名）
          shopt -s nullglob

          # 先编译单源 JSON
          for f in rules-src/*.json; do
            name=$(basename "$f" .json)
            ./sb/sing-box rule-set compile --from "$f" --output "srs/${name}.srs"
          done

          # 合并编译（同名的 ip.json + domain.json）
          for ipjson in rules-src/*.ip.json; do
            base=${ipjson%.ip.json}
            domainjson="${base}.domain.json"
            name=$(basename "$base")
            if [ -f "$domainjson" ]; then
              ./sb/sing-box rule-set compile --from "$ipjson" --from "$domainjson" --output "srs/${name}.srs"
            fi
          done

      - name: Upload SRS artifacts
        if: steps.copy_step.outputs.changed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: srs-files
          path: srs

      - name: Commit SRS to repository
        if: steps.copy_step.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add srs || true
          git commit -m "自动编译更新 SRS" || true
          git push
